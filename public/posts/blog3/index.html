<!doctype html><html lang=en dir=auto data-theme=dark><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2dgameengine | 雄一のサイト</title><meta name=keywords content><meta name=description content="Libraries and Dependencies
Compile and Link
Compile and link are two different stages.
Compiler stage

compile stage
compiler reads your .cpp
compiler reads header files (.h)
compiler checks:

“Does this function name exist?”
“Are argument types correct?”
“Is the structure defined?”


compiler generates .o (object files)

Link stage

linker takes object files + binary libraries
linker attaches real implementations from .so/.a
produces the final executable

So:

  
      
          Stage
          Needs headers?
          Needs binaries?
      
  
  
      
          Compile
          Yes
          No
      
      
          Link
          No
          Yes
      
  

Q&amp;A from cource

Q
You explain that we install the binaries for e.g. SDL. But why do we then include  .h files (e.g. SDL.h). Are header files not text files?
A
So, even when we are using binaries (.libs), we still need to add a .h file to our project.
Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use.
For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type.
When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects.
After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable.
So, that&rsquo;s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function.
That&rsquo;s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website.

Static vs Dynamic Libraries
1. Static Libraries (.lib / .a)

Library code is copied into the final executable at link time.
Each program gets its own private copy of the code.
Results in a larger executable and higher overall memory usage.
Cannot be shared between multiple running programs.
Common file extensions:

Windows: .lib
Linux/Unix: .a



2. Dynamic Libraries (.dll / .so)

Library code stays outside the executable and is loaded at runtime.
Multiple programs can share the same library in memory.
Executable size is smaller and memory use is more efficient.
Common file extensions:

Windows: .dll
Linux/Unix: .so



Comparison Table

  
      
          Feature
          Static (.lib/.a)
          Dynamic (.dll/.so)
      
  
  
      
          Link time
          Build time
          Run time
      
      
          Executable size
          Larger
          Smaller
      
      
          Memory usage
          Higher (duplicate copies)
          Lower (shared)
      
      
          Sharing allowed
          No
          Yes
      
      
          Code location
          Inside the executable
          External file loaded dynamically
      
  

Key Idea Summary

Static library: code is copied into your program.
Dynamic library: code is shared at runtime among programs.

Displaying the Game Window
Game Loop
Game Loop

Process Input
Update Game
Render (display stuff)

while (true) {
  game -> processInput();
  game -> update();
  game -> render();
 }
Game loop on game engine
The game engine already provides the core game loop.
When we write scripts to control game objects, the game engine exposes several key functions for us to override."><meta name=author content="Yuichi Tsunoda"><link rel=canonical href=http://localhost:1313/posts/blog3/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/blog3/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/blog3/"><meta property="og:site_name" content="雄一のサイト"><meta property="og:title" content="2dgameengine"><meta property="og:description" content="Libraries and Dependencies Compile and Link Compile and link are two different stages.
Compiler stage compile stage compiler reads your .cpp compiler reads header files (.h) compiler checks: “Does this function name exist?” “Are argument types correct?” “Is the structure defined?” compiler generates .o (object files) Link stage linker takes object files + binary libraries linker attaches real implementations from .so/.a produces the final executable So:
Stage Needs headers? Needs binaries? Compile Yes No Link No Yes Q&amp;A from cource Q You explain that we install the binaries for e.g. SDL. But why do we then include .h files (e.g. SDL.h). Are header files not text files? A So, even when we are using binaries (.libs), we still need to add a .h file to our project. Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use. For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type. When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects. After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable. So, that’s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function. That’s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website. Static vs Dynamic Libraries 1. Static Libraries (.lib / .a) Library code is copied into the final executable at link time. Each program gets its own private copy of the code. Results in a larger executable and higher overall memory usage. Cannot be shared between multiple running programs. Common file extensions: Windows: .lib Linux/Unix: .a 2. Dynamic Libraries (.dll / .so) Library code stays outside the executable and is loaded at runtime. Multiple programs can share the same library in memory. Executable size is smaller and memory use is more efficient. Common file extensions: Windows: .dll Linux/Unix: .so Comparison Table Feature Static (.lib/.a) Dynamic (.dll/.so) Link time Build time Run time Executable size Larger Smaller Memory usage Higher (duplicate copies) Lower (shared) Sharing allowed No Yes Code location Inside the executable External file loaded dynamically Key Idea Summary Static library: code is copied into your program. Dynamic library: code is shared at runtime among programs. Displaying the Game Window Game Loop Game Loop Process Input Update Game Render (display stuff) while (true) { game -> processInput(); game -> update(); game -> render(); } Game loop on game engine The game engine already provides the core game loop. When we write scripts to control game objects, the game engine exposes several key functions for us to override."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-29T00:00:00+09:00"><meta property="article:modified_time" content="2025-12-29T00:00:00+09:00"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="2dgameengine"><meta name=twitter:description content="Libraries and Dependencies
Compile and Link
Compile and link are two different stages.
Compiler stage

compile stage
compiler reads your .cpp
compiler reads header files (.h)
compiler checks:

“Does this function name exist?”
“Are argument types correct?”
“Is the structure defined?”


compiler generates .o (object files)

Link stage

linker takes object files + binary libraries
linker attaches real implementations from .so/.a
produces the final executable

So:

  
      
          Stage
          Needs headers?
          Needs binaries?
      
  
  
      
          Compile
          Yes
          No
      
      
          Link
          No
          Yes
      
  

Q&amp;A from cource

Q
You explain that we install the binaries for e.g. SDL. But why do we then include  .h files (e.g. SDL.h). Are header files not text files?
A
So, even when we are using binaries (.libs), we still need to add a .h file to our project.
Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use.
For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type.
When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects.
After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable.
So, that&rsquo;s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function.
That&rsquo;s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website.

Static vs Dynamic Libraries
1. Static Libraries (.lib / .a)

Library code is copied into the final executable at link time.
Each program gets its own private copy of the code.
Results in a larger executable and higher overall memory usage.
Cannot be shared between multiple running programs.
Common file extensions:

Windows: .lib
Linux/Unix: .a



2. Dynamic Libraries (.dll / .so)

Library code stays outside the executable and is loaded at runtime.
Multiple programs can share the same library in memory.
Executable size is smaller and memory use is more efficient.
Common file extensions:

Windows: .dll
Linux/Unix: .so



Comparison Table

  
      
          Feature
          Static (.lib/.a)
          Dynamic (.dll/.so)
      
  
  
      
          Link time
          Build time
          Run time
      
      
          Executable size
          Larger
          Smaller
      
      
          Memory usage
          Higher (duplicate copies)
          Lower (shared)
      
      
          Sharing allowed
          No
          Yes
      
      
          Code location
          Inside the executable
          External file loaded dynamically
      
  

Key Idea Summary

Static library: code is copied into your program.
Dynamic library: code is shared at runtime among programs.

Displaying the Game Window
Game Loop
Game Loop

Process Input
Update Game
Render (display stuff)

while (true) {
  game -> processInput();
  game -> update();
  game -> render();
 }
Game loop on game engine
The game engine already provides the core game loop.
When we write scripts to control game objects, the game engine exposes several key functions for us to override."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"2dgameengine","item":"http://localhost:1313/posts/blog3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2dgameengine","name":"2dgameengine","description":"Libraries and Dependencies Compile and Link Compile and link are two different stages.\nCompiler stage compile stage compiler reads your .cpp compiler reads header files (.h) compiler checks: “Does this function name exist?” “Are argument types correct?” “Is the structure defined?” compiler generates .o (object files) Link stage linker takes object files + binary libraries linker attaches real implementations from .so/.a produces the final executable So:\nStage Needs headers? Needs binaries? Compile Yes No Link No Yes Q\u0026amp;A from cource Q You explain that we install the binaries for e.g. SDL. But why do we then include .h files (e.g. SDL.h). Are header files not text files? A So, even when we are using binaries (.libs), we still need to add a .h file to our project. Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use. For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type. When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects. After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable. So, that\u0026rsquo;s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function. That\u0026rsquo;s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website. Static vs Dynamic Libraries 1. Static Libraries (.lib / .a) Library code is copied into the final executable at link time. Each program gets its own private copy of the code. Results in a larger executable and higher overall memory usage. Cannot be shared between multiple running programs. Common file extensions: Windows: .lib Linux/Unix: .a 2. Dynamic Libraries (.dll / .so) Library code stays outside the executable and is loaded at runtime. Multiple programs can share the same library in memory. Executable size is smaller and memory use is more efficient. Common file extensions: Windows: .dll Linux/Unix: .so Comparison Table Feature Static (.lib/.a) Dynamic (.dll/.so) Link time Build time Run time Executable size Larger Smaller Memory usage Higher (duplicate copies) Lower (shared) Sharing allowed No Yes Code location Inside the executable External file loaded dynamically Key Idea Summary Static library: code is copied into your program. Dynamic library: code is shared at runtime among programs. Displaying the Game Window Game Loop Game Loop Process Input Update Game Render (display stuff) while (true) { game -\u0026gt; processInput(); game -\u0026gt; update(); game -\u0026gt; render(); } Game loop on game engine The game engine already provides the core game loop. When we write scripts to control game objects, the game engine exposes several key functions for us to override.\n","keywords":[],"articleBody":"Libraries and Dependencies Compile and Link Compile and link are two different stages.\nCompiler stage compile stage compiler reads your .cpp compiler reads header files (.h) compiler checks: “Does this function name exist?” “Are argument types correct?” “Is the structure defined?” compiler generates .o (object files) Link stage linker takes object files + binary libraries linker attaches real implementations from .so/.a produces the final executable So:\nStage Needs headers? Needs binaries? Compile Yes No Link No Yes Q\u0026A from cource Q You explain that we install the binaries for e.g. SDL. But why do we then include .h files (e.g. SDL.h). Are header files not text files? A So, even when we are using binaries (.libs), we still need to add a .h file to our project. Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use. For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type. When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects. After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable. So, that’s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function. That’s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website. Static vs Dynamic Libraries 1. Static Libraries (.lib / .a) Library code is copied into the final executable at link time. Each program gets its own private copy of the code. Results in a larger executable and higher overall memory usage. Cannot be shared between multiple running programs. Common file extensions: Windows: .lib Linux/Unix: .a 2. Dynamic Libraries (.dll / .so) Library code stays outside the executable and is loaded at runtime. Multiple programs can share the same library in memory. Executable size is smaller and memory use is more efficient. Common file extensions: Windows: .dll Linux/Unix: .so Comparison Table Feature Static (.lib/.a) Dynamic (.dll/.so) Link time Build time Run time Executable size Larger Smaller Memory usage Higher (duplicate copies) Lower (shared) Sharing allowed No Yes Code location Inside the executable External file loaded dynamically Key Idea Summary Static library: code is copied into your program. Dynamic library: code is shared at runtime among programs. Displaying the Game Window Game Loop Game Loop Process Input Update Game Render (display stuff) while (true) { game -\u003e processInput(); game -\u003e update(); game -\u003e render(); } Game loop on game engine The game engine already provides the core game loop. When we write scripts to control game objects, the game engine exposes several key functions for us to override.\nThree important functions\nSETUP Initializes the game state. Called once at the very beginning. Used to configure initial positions, colors, speeds, and any starting values. UPDATE Updates game objects every frame. Called multiple times per second (depending on the frame rate). Handles movement, physics, input, and gameplay logic. DRAW (or RENDER) Renders all game objects to the screen. Also called multiple times per second. Handles drawing sprites, shapes, and UI elements each frame. Summary\nSETUP: runs once → initialize game. UPDATE: runs every frame → update game logic. DRAW: runs every frame → render visuals. Game Class In OOP languages like C++, you can create classes to divide the responsibilities of the process.\nInclude file/folder When you include the file at the same folder (sibling file), use double quote \" to import it. When you include the operating system include folder, use angle bracket \u003c \u003e to import it.\n#include \"Game.h\" #include To use the function from the Game class, the only thing you need to include is the Game.h header file. This is because the compiler only cares about the function names and their parameters. The actual implementations of the functions written in Game.cpp are not required during complilation; they are added later during the linking stage. At that stage, the linker combines all the function implementations into the final executable.\nProtection Guard Whenever we declare a header file, we need to add a protection guard. The protection guard makes the preprocessor include the header file once in the entire project. In C++ we include a header file all over the place. So, we need to prevent the preprocessor from copying the same header file multiple times.\n#pragma once class Game { //... }; Store object in the stack Since we are not using the new keyword to create the object, this object will be stored in the stack and will be destroyed when the scope ends.\nint main(int argc, char* argv[]) { // Create the object on stack Game game; // 'new Game()' dynamically allocates memory in the heap, not the stack // This allocation does not end automatically when scope ends. Game* game = new Game(); // So, you must delete it manually delete game; return 0; } Creating an SDL Window Renderer A renderer is the object responsible for drawing into the window.\nThe renderer:\nHandles all drawing commands (clear screen, draw textures, draw shapes, copy images, etc.) Sends your drawing to the GPU Controls color, textures, blending, etc. Updates the window when you call SDL_RenderPresent void Game::Initialize() { // Initialize SDL... // Initialize Window... // Create to renderer to go inside the window SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0); } Fullscreen Window (Fake-Fullscreen) Display Mode API SDL uses a C-style API. Instead of returning a full struct, functions like SDL_GetCurrentDisplayMode take a pointer to a struct and write data directly into that struct.\nThis approach is common in C libraries for several important reasons:\nC functions can only return one value, so using a struct pointer allows the function to return multiple pieces of information at once. Returning large structs by value would require copying memory, which is inefficient. Passing a pointer avoids unnecessary memory operations. SDL is implemented in pure C, so its API follows traditional C conventions to maintain compatibility with both C and C++. After the function call, the struct you provided will be populated with the current display’s properties. In particular, displayMode.w and displayMode.h will contain the monitor’s resolution.\nKey points:\nSDL’s API uses pass-by-reference (pointer) style because of C language design. You create an empty struct and pass its address; SDL fills in the fields. No value copying is involved; the struct is modified directly for efficiency. After the function call, you can read the updated width and height from it. SDL_DisplayMode displayMode; // Struct to hold display information SDL_GetCurrentDisplayMode( 0, // Display index (0 = primary monitor) \u0026displayMode // Pass pointer so the function can fill the struct ); // The struct now contains the screen resolution windowWidth = displayMode.w; // Retrieved monitor width windowHeight = displayMode.h; // Retrieved monitor height Change the video mode Change the video mode to the actual full-screen.\nSDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN); Fake Fullscreen vs Real Fullscreen Best Solution for Setting the Screen One simple way to run your game in fullscreen mode is to manually specify a fixed resolution and then instruct SDL to switch the window into fullscreen video mode. In this approach, you directly assign the desired width and height to your window variables, and SDL will attempt to scale or adapt the window to match the monitor’s fullscreen mode. Different players may have different monitor environments (aspect ratios, resolutions, and scaling factors), so simply switching to fullscreen can cause the visible area of the game to vary from player to player. By defining a fixed rendering resolution yourself, you ensure that the portion of the game world shown on the screen is always consistent regardless of the user’s monitor, because SDL will scale your defined resolution to fit their display.\nBelow is an example:\nwindowWidth = 800; // Desired width for the fullscreen window windowHeight = 600; // Desired height for the fullscreen window // Switch the window into fullscreen mode using the chosen resolution SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN); This approach forces SDL to use your specified resolution when entering fullscreen mode. It is simple and predictable, making it useful when your game is designed for a specific resolution or when you want full control over the rendering dimensions and the exact area of the game world that players see, independent of their monitor setup.\nUnderstanding the SDL Renderer (GPU Acceleration and VSync) It is helpful to understand how SDL handles rendering behind the scenes. SDL is a smart library, and by default it will try to detect whether the system has a dedicated graphics card (GPU) and use it to render objects on the screen. When we create a renderer using SDL_CreateRenderer, we can optionally specify flags that tell SDL how we want the rendering to behave.\nOne important flag is SDL_RENDERER_ACCELERATED. This flag instructs SDL to attempt to use hardware acceleration instead of software rendering. In most cases, SDL will choose this automatically, but setting the flag explicitly ensures that SDL will try to find and use the GPU.\nSDL_CreateRenderer( window, -1, SDL_RENDERER_ACCELERATED ); Another useful flag is SDL_RENDERER_PRESENTVSYNC. VSync (vertical synchronization) is a technique that synchronizes the game’s frame rendering with the monitor’s refresh rate. Enabling VSync helps prevent screen tearing artifacts, because it forces each frame to be presented only when the monitor is ready to refresh. However, enabling VSync will limit your rendering FPS to the monitor’s refresh rate. For example, even if your game can render at 3000 FPS, enabling VSync on a 60Hz monitor will cap your rendering FPS at 60. Although the frame rate is limited, you can still update game logic or physics at a higher frequency if needed.\nWe can combine both GPU acceleration and VSync by using the bitwise OR operator. This tells SDL that we want to enable hardware acceleration and also enable VSync to prevent screen tearing:\nSDL_CreateRenderer( window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC ); Using these two flags provides a powerful and flexible configuration: SDL will render using the GPU whenever possible, and VSync will help ensure a smooth visual experience without tearing artifacts.\nRendering SDL Objects Double-Buffered Renderer When we call SDL_RenderPresent(renderer), SDL performs a buffer swap that makes the newly rendered frame visible on the screen. Internally, SDL uses a double-buffering system consisting of a front buffer and a back buffer.\nThe front buffer is the image currently displayed on the monitor. The back buffer is where SDL draws the next frame while the front buffer is still being shown. All rendering commands (such as drawing textures, shapes, or clearing the screen) are applied only to the back buffer. This keeps the currently visible image stable while the new frame is being prepared in the background.\nWhen the frame is fully drawn, calling SDL_RenderPresent(renderer) swaps the two buffers:\nThe back buffer becomes the new front buffer and is displayed on the screen. The old front buffer becomes the new back buffer, ready to be drawn on for the next frame. This double-buffering system prevents flickering and tearing, because partially drawn frames are never shown to the player. Only fully completed frames are displayed after the buffer swap.\n// Present the renderer to the screen (swap back buffer → front buffer) SDL_RenderPresent(renderer); Initialize our game object Setup() is usually a function that is called once, at the beginning of your game. It can be used to initialize our game object values and properties.\nDrawing a PNG Texture SDL_Surface* surface = IMG_Load(\"./assets/images/tank-tiger-right.png\"); SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface); SDL_FreeSurface(surface); SDL_Rect dstRect = { 10, 10, 32, 32 }; SDL_RenderCopy(renderer, texture, \u003csrcRect\u003e,\u003cdstRect\u003e); SDL_DestroyTexture(texture); This code loads a PNG image from disk, converts it into a format that the GPU can draw, and then renders it on the screen.\nSDL_Surface* surface = IMG_Load(\"./assets/images/tank-tiger-right.png\"); When we call IMG_Load, SDL loads the PNG file and places the pixel data into a surface. A surface is simply raw image data stored in normal RAM. It represents an image that the CPU can access, but it is not in a format that the GPU can draw efficiently.\nSDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface); To render the image on the screen, we must convert the surface into a texture. A texture is the GPU-friendly version of the image. Textures live on the graphics card and can be drawn very efficiently by the renderer.\nSDL_FreeSurface(surface); After converting the image into a texture, the original surface is no longer needed, so we free it to avoid wasting memory.\nSDL_Rect dstRect = { 10, 10, 32, 32 }; SDL_RenderCopy(renderer, texture, \u003csrcRect\u003e, \u003cdstRect\u003e); Finally, SDL_RenderCopy copies the texture onto the current back buffer. The srcRect specifies which part of the texture to use, and the dstRect specifies where and how large it should appear on the screen. In most of the case, we want to use the entire texture. So, If you want to draw the whole image, you can pass NULL.\nSDL_DestroyTexture(texture); After converting an image into a texture and drawing it with SDL_RenderCopy, we should free the memory used by the texture when we are done with it. SDL textures live on the GPU, which means they consume graphics memory. If we never destroy them, the GPU memory will eventually fill up, causing performance problems or crashes. To release the texture properly, we call SDL_DestroyTexture.\nThis tells SDL to remove the texture from the GPU and free all resources associated with it. It is the GPU equivalent of freeing a surface with SDL_FreeSurface. Always make sure to destroy textures once you are done drawing them, especially inside loops or when loading many images.\nFixing the Game Time Step Object Movement and Velocity Vectors ","wordCount":"2393","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-12-29T00:00:00+09:00","dateModified":"2025-12-29T00:00:00+09:00","author":[{"@type":"Person","name":"Yuichi Tsunoda"}],"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/blog3/"},"publisher":{"@type":"Organization","name":"雄一のサイト","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/posts/ title=posts><span>posts</span></a></li><li><a href=http://localhost:1313/categories/ title=categories><span>categories</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">2dgameengine</h1><div class=post-meta><span title='2025-12-29 00:00:00 +0900 JST'>December 29, 2025</span>&nbsp;·&nbsp;<span>12 min</span>&nbsp;·&nbsp;<span>2393 words</span>&nbsp;·&nbsp;<span>Yuichi Tsunoda</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/blog3.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=post-content><h2 id=libraries-and-dependencies>Libraries and Dependencies<a hidden class=anchor aria-hidden=true href=#libraries-and-dependencies>#</a></h2><h3 id=compile-and-link>Compile and Link<a hidden class=anchor aria-hidden=true href=#compile-and-link>#</a></h3><p>Compile and link are two different stages.</p><h4 id=compiler-stage>Compiler stage<a hidden class=anchor aria-hidden=true href=#compiler-stage>#</a></h4><ul><li>compile stage</li><li>compiler reads your .cpp</li><li>compiler reads header files (.h)</li><li>compiler checks:<ul><li>“Does this function name exist?”</li><li>“Are argument types correct?”</li><li>“Is the structure defined?”</li></ul></li><li>compiler generates .o (object files)</li></ul><h4 id=link-stage>Link stage<a hidden class=anchor aria-hidden=true href=#link-stage>#</a></h4><ul><li>linker takes object files + binary libraries</li><li>linker attaches real implementations from .so/.a</li><li>produces the final executable</li></ul><p>So:</p><table><thead><tr><th>Stage</th><th>Needs headers?</th><th>Needs binaries?</th></tr></thead><tbody><tr><td>Compile</td><td>Yes</td><td>No</td></tr><tr><td>Link</td><td>No</td><td>Yes</td></tr></tbody></table><h4 id=q-and-a-from-cource>Q&amp;A from cource<a hidden class=anchor aria-hidden=true href=#q-and-a-from-cource>#</a></h4><dl><dt>Q</dt><dd>You explain that we install the binaries for e.g. SDL. But why do we then include <strong>.h files (e.g. SDL.h). Are header files not text files?</strong></dd><dt>A</dt><dd><strong>So, even when we are using binaries (.libs), we still need to add a .h file to our project.</strong>
Header files (.h) are indeed source-code/text files, but the main goal of a header file is to expose the API of those binaries that we are trying to use.
For example, when we include the binary of the SDL library, we need to also add the .h files for SDL. These .h files will tell the compiler important things, like what are the function names and the order of the parameters and also their type.
When we compile our project, the compiler only looks at the header files and does a quick check to see if the function names are correct and the parameters are the ones that the header file expects.
After the compiler says everything looks good and our calls match what the header file expects, the linker is the one responsible for bundling the implementation/binaries of those functions with our final executable.
So, that&rsquo;s the reason why we still need .h files. These header files are source code files, but they only tell the compiler what we can call from those binaries. I always like to think that the header file tells the compiler what are the names of the functions we can call, their return type, and also the parameters with their types and the order we need to pass them to the function.
That&rsquo;s the reason we downloaded both the Windows binaries (.lib) and the header files (.h) from the SDL official website.</dd></dl><h3 id=static-vs-dynamic-libraries>Static vs Dynamic Libraries<a hidden class=anchor aria-hidden=true href=#static-vs-dynamic-libraries>#</a></h3><h4 id=1-dot-static-libraries--dot-lib-dot-a>1. Static Libraries (.lib / .a)<a hidden class=anchor aria-hidden=true href=#1-dot-static-libraries--dot-lib-dot-a>#</a></h4><ul><li>Library code is copied into the final executable at link time.</li><li>Each program gets its own private copy of the code.</li><li>Results in a larger executable and higher overall memory usage.</li><li>Cannot be shared between multiple running programs.</li><li>Common file extensions:<ul><li>Windows: .lib</li><li>Linux/Unix: .a</li></ul></li></ul><h4 id=2-dot-dynamic-libraries--dot-dll-dot-so>2. Dynamic Libraries (.dll / .so)<a hidden class=anchor aria-hidden=true href=#2-dot-dynamic-libraries--dot-dll-dot-so>#</a></h4><ul><li>Library code stays outside the executable and is loaded at runtime.</li><li>Multiple programs can share the same library in memory.</li><li>Executable size is smaller and memory use is more efficient.</li><li>Common file extensions:<ul><li>Windows: .dll</li><li>Linux/Unix: .so</li></ul></li></ul><h4 id=comparison-table>Comparison Table<a hidden class=anchor aria-hidden=true href=#comparison-table>#</a></h4><table><thead><tr><th>Feature</th><th>Static (.lib/.a)</th><th>Dynamic (.dll/.so)</th></tr></thead><tbody><tr><td>Link time</td><td>Build time</td><td>Run time</td></tr><tr><td>Executable size</td><td>Larger</td><td>Smaller</td></tr><tr><td>Memory usage</td><td>Higher (duplicate copies)</td><td>Lower (shared)</td></tr><tr><td>Sharing allowed</td><td>No</td><td>Yes</td></tr><tr><td>Code location</td><td>Inside the executable</td><td>External file loaded dynamically</td></tr></tbody></table><h4 id=key-idea-summary>Key Idea Summary<a hidden class=anchor aria-hidden=true href=#key-idea-summary>#</a></h4><ul><li>Static library: code is <strong>copied</strong> into your program.</li><li>Dynamic library: code is <strong>shared</strong> at runtime among programs.</li></ul><h2 id=displaying-the-game-window>Displaying the Game Window<a hidden class=anchor aria-hidden=true href=#displaying-the-game-window>#</a></h2><h3 id=game-loop>Game Loop<a hidden class=anchor aria-hidden=true href=#game-loop>#</a></h3><h4 id=game-loop>Game Loop<a hidden class=anchor aria-hidden=true href=#game-loop>#</a></h4><ol><li>Process Input</li><li>Update Game</li><li>Render (display stuff)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>game</span> <span class=o>-&gt;</span> <span class=n>processInput</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>game</span> <span class=o>-&gt;</span> <span class=n>update</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>game</span> <span class=o>-&gt;</span> <span class=n>render</span><span class=p>();</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span></code></pre></div><h4 id=game-loop-on-game-engine>Game loop on game engine<a hidden class=anchor aria-hidden=true href=#game-loop-on-game-engine>#</a></h4><p>The game engine already provides the core game loop.
When we write scripts to control game objects, the game engine exposes several key functions for us to override.</p><ul><li><p>Three important functions</p><ol><li><code>SETUP</code><ul><li>Initializes the game state.</li><li>Called <strong>once</strong> at the very beginning.</li><li>Used to configure initial positions, colors, speeds, and any starting values.</li></ul></li><li><code>UPDATE</code><ul><li>Updates game objects every frame.</li><li>Called <strong>multiple times per second</strong> (depending on the frame rate).</li><li>Handles movement, physics, input, and gameplay logic.</li></ul></li><li><code>DRAW</code> (or <code>RENDER</code>)<ul><li>Renders all game objects to the screen.</li><li>Also called <strong>multiple times per second</strong>.</li><li>Handles drawing sprites, shapes, and UI elements each frame.</li></ul></li></ol></li></ul><ul><li><p>Summary</p><ul><li><strong>SETUP</strong>: runs once → initialize game.</li><li><strong>UPDATE</strong>: runs every frame → update game logic.</li><li><strong>DRAW</strong>: runs every frame → render visuals.</li></ul></li></ul><h3 id=game-class>Game Class<a hidden class=anchor aria-hidden=true href=#game-class>#</a></h3><p>In OOP languages like C++, you can create classes to divide the responsibilities of the process.</p><h4 id=include-file-folder>Include file/folder<a hidden class=anchor aria-hidden=true href=#include-file-folder>#</a></h4><p>When you include the file at the same folder (sibling file), use double quote <code>"</code> to import it.
When you include the operating system include folder, use angle bracket <code>&lt; ></code> to import it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Game.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;SDL.h&gt;</span><span class=cp>
</span></span></span></code></pre></div><p>To use the function from the <code>Game</code> class, the only thing you need to include is the <code>Game.h</code> header file.
This is because the compiler only cares about the <code>function names</code> and their <code>parameters</code>.
The actual implementations of the functions written in <code>Game.cpp</code> are not required during complilation; they are added later during the <code>linking stage</code>.
At that stage, the linker combines all the function implementations into the final executable.</p><h4 id=protection-guard>Protection Guard<a hidden class=anchor aria-hidden=true href=#protection-guard>#</a></h4><p>Whenever we declare a header file, we need to add a protection guard.
The protection guard makes the preprocessor include the header file once in the entire project.
In C++ we include a header file all over the place.
So, we need to prevent the preprocessor from copying the same header file multiple times.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Game</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...
</span></span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h4 id=store-object-in-the-stack>Store object in the stack<a hidden class=anchor aria-hidden=true href=#store-object-in-the-stack>#</a></h4><p>Since we are not using the <code>new</code> keyword to create the object, this object will be stored in the <code>stack</code> and will be destroyed when the scope ends.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create the object on stack
</span></span></span><span class=line><span class=cl>    <span class=n>Game</span> <span class=n>game</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// &#39;new Game()&#39; dynamically allocates memory in the heap, not the stack
</span></span></span><span class=line><span class=cl>    <span class=c1>// This allocation does not end automatically when scope ends.
</span></span></span><span class=line><span class=cl>    <span class=n>Game</span><span class=o>*</span> <span class=n>game</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Game</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// So, you must delete it manually
</span></span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>game</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=creating-an-sdl-window>Creating an SDL Window<a hidden class=anchor aria-hidden=true href=#creating-an-sdl-window>#</a></h3><h4 id=renderer>Renderer<a hidden class=anchor aria-hidden=true href=#renderer>#</a></h4><p>A renderer is the object responsible for <code>drawing</code> into the window.</p><p>The renderer:</p><ul><li>Handles all drawing commands
(clear screen, draw textures, draw shapes, copy images, etc.)</li><li>Sends your drawing to the GPU</li><li>Controls color, textures, blending, etc.</li><li>Updates the window when you call <code>SDL_RenderPresent</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>Game</span><span class=o>::</span><span class=n>Initialize</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Initialize SDL...
</span></span></span><span class=line><span class=cl>    <span class=c1>// Initialize Window...
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Create to renderer to go inside the window
</span></span></span><span class=line><span class=cl>    <span class=n>SDL_Renderer</span><span class=o>*</span> <span class=n>renderer</span> <span class=o>=</span> <span class=n>SDL_CreateRenderer</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=fullscreen-window--fake-fullscreen>Fullscreen Window (Fake-Fullscreen)<a hidden class=anchor aria-hidden=true href=#fullscreen-window--fake-fullscreen>#</a></h3><h4 id=display-mode-api>Display Mode API<a hidden class=anchor aria-hidden=true href=#display-mode-api>#</a></h4><p>SDL uses a C-style API. Instead of returning a full struct, functions like <code>SDL_GetCurrentDisplayMode</code> take a <code>pointer to a struct</code> and <code>write data directly into that struct</code>.</p><p>This approach is common in C libraries for several important reasons:</p><ul><li>C functions can only return one value, so using a struct pointer allows the function to return <code>multiple pieces of information</code> at once.</li><li>Returning large structs by value would require copying memory, which is inefficient. Passing a pointer avoids unnecessary memory operations.</li><li>SDL is implemented in pure C, so its API follows <code>traditional C conventions</code> to maintain compatibility with both C and C++.</li></ul><p>After the function call, the struct you provided will be populated with the current display&rsquo;s properties. In particular, <code>displayMode.w</code> and <code>displayMode.h</code> will contain the monitor’s resolution.</p><p>Key points:</p><ul><li>SDL’s API uses <code>pass-by-reference</code> (pointer) style because of C language design.</li><li>You create an <code>empty struct</code> and pass its address; SDL <code>fills in the fields</code>.</li><li>No value copying is involved; the struct is <code>modified directly</code> for efficiency.</li><li>After the function call, you can read the <code>updated width and height</code> from it.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_DisplayMode</span> <span class=n>displayMode</span><span class=p>;</span>    <span class=c1>// Struct to hold display information
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SDL_GetCurrentDisplayMode</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=mi>0</span><span class=p>,</span>               <span class=c1>// Display index (0 = primary monitor)
</span></span></span><span class=line><span class=cl>    <span class=o>&amp;</span><span class=n>displayMode</span>     <span class=c1>// Pass pointer so the function can fill the struct
</span></span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The struct now contains the screen resolution
</span></span></span><span class=line><span class=cl><span class=n>windowWidth</span>  <span class=o>=</span> <span class=n>displayMode</span><span class=p>.</span><span class=n>w</span><span class=p>;</span>   <span class=c1>// Retrieved monitor width
</span></span></span><span class=line><span class=cl><span class=n>windowHeight</span> <span class=o>=</span> <span class=n>displayMode</span><span class=p>.</span><span class=n>h</span><span class=p>;</span>   <span class=c1>// Retrieved monitor height
</span></span></span></code></pre></div><h4 id=change-the-video-mode>Change the video mode<a hidden class=anchor aria-hidden=true href=#change-the-video-mode>#</a></h4><p>Change the video mode to the actual full-screen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_SetWindowFullscreen</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=n>SDL_WINDOW_FULLSCREEN</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=fake-fullscreen-vs-real-fullscreen>Fake Fullscreen vs Real Fullscreen<a hidden class=anchor aria-hidden=true href=#fake-fullscreen-vs-real-fullscreen>#</a></h3><h4 id=best-solution-for-setting-the-screen>Best Solution for Setting the Screen<a hidden class=anchor aria-hidden=true href=#best-solution-for-setting-the-screen>#</a></h4><p>One simple way to run your game in fullscreen mode is to manually specify a fixed resolution and then instruct SDL to switch the window into fullscreen video mode. In this approach, you directly assign the desired width and height to your window variables, and SDL will attempt to scale or adapt the window to match the monitor&rsquo;s fullscreen mode. Different players may have different monitor environments (aspect ratios, resolutions, and scaling factors), so simply switching to fullscreen can cause the visible area of the game to vary from player to player. By defining a fixed rendering resolution yourself, you ensure that the portion of the game world shown on the screen is always consistent regardless of the user’s monitor, because SDL will scale your defined resolution to fit their display.</p><p>Below is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>windowWidth</span>  <span class=o>=</span> <span class=mi>800</span><span class=p>;</span>   <span class=c1>// Desired width for the fullscreen window
</span></span></span><span class=line><span class=cl><span class=n>windowHeight</span> <span class=o>=</span> <span class=mi>600</span><span class=p>;</span>   <span class=c1>// Desired height for the fullscreen window
</span></span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Switch the window into fullscreen mode using the chosen resolution
</span></span></span><span class=line><span class=cl><span class=n>SDL_SetWindowFullscreen</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=n>SDL_WINDOW_FULLSCREEN</span><span class=p>);</span>
</span></span></code></pre></div><p>This approach forces SDL to use your specified resolution when entering fullscreen mode. It is simple and predictable, making it useful when your game is designed for a specific resolution or when you want full control over the rendering dimensions and the exact area of the game world that players see, independent of their monitor setup.</p><h3 id=understanding-the-sdl-renderer--gpu-acceleration-and-vsync>Understanding the SDL Renderer (GPU Acceleration and VSync)<a hidden class=anchor aria-hidden=true href=#understanding-the-sdl-renderer--gpu-acceleration-and-vsync>#</a></h3><p>It is helpful to understand how SDL handles rendering behind the scenes. SDL is a smart library, and by default it will try to detect whether the system has a dedicated graphics card (GPU) and use it to render objects on the screen. When we create a renderer using <code>SDL_CreateRenderer</code>, we can optionally specify flags that tell SDL how we want the rendering to behave.</p><p>One important flag is <code>SDL_RENDERER_ACCELERATED</code>. This flag instructs SDL to attempt to use hardware acceleration instead of software rendering. In most cases, SDL will choose this automatically, but setting the flag explicitly ensures that SDL will try to find and use the GPU.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_CreateRenderer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>window</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_RENDERER_ACCELERATED</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>Another useful flag is <code>SDL_RENDERER_PRESENTVSYNC</code>. VSync (vertical synchronization) is a technique that synchronizes the game&rsquo;s frame rendering with the monitor&rsquo;s refresh rate. Enabling VSync helps prevent screen tearing artifacts, because it forces each frame to be presented only when the monitor is ready to refresh. However, enabling VSync will limit your rendering FPS to the monitor&rsquo;s refresh rate. For example, even if your game can render at 3000 FPS, enabling VSync on a 60Hz monitor will cap your rendering FPS at 60. Although the frame rate is limited, you can still update game logic or physics at a higher frequency if needed.</p><p>We can combine both GPU acceleration and VSync by using the bitwise OR operator. This tells SDL that we want to enable hardware acceleration and also enable VSync to prevent screen tearing:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_CreateRenderer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>window</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>-</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_RENDERER_ACCELERATED</span> <span class=o>|</span> <span class=n>SDL_RENDERER_PRESENTVSYNC</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>Using these two flags provides a powerful and flexible configuration: SDL will render using the GPU whenever possible, and VSync will help ensure a smooth visual experience without tearing artifacts.</p><h2 id=rendering-sdl-objects>Rendering SDL Objects<a hidden class=anchor aria-hidden=true href=#rendering-sdl-objects>#</a></h2><h3 id=double-buffered-renderer>Double-Buffered Renderer<a hidden class=anchor aria-hidden=true href=#double-buffered-renderer>#</a></h3><p>When we call <code>SDL_RenderPresent(renderer)</code>, SDL performs a buffer swap that makes the newly rendered frame visible on the screen. Internally, SDL uses a double-buffering system consisting of a <code>front buffer</code> and a <code>back buffer</code>.</p><ul><li>The <code>front buffer</code> is the image currently displayed on the monitor.</li><li>The <code>back buffer</code> is where SDL draws the next frame while the front buffer is still being shown.</li></ul><p>All rendering commands (such as drawing textures, shapes, or clearing the screen) are applied only to the <code>back buffer</code>. This keeps the currently visible image stable while the new frame is being prepared in the background.</p><p>When the frame is fully drawn, calling <code>SDL_RenderPresent(renderer)</code> swaps the two buffers:</p><ol><li>The back buffer becomes the new front buffer and is displayed on the screen.</li><li>The old front buffer becomes the new back buffer, ready to be drawn on for the next frame.</li></ol><p>This double-buffering system prevents flickering and tearing, because partially drawn frames are never shown to the player. Only fully completed frames are displayed after the buffer swap.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Present the renderer to the screen (swap back buffer → front buffer)
</span></span></span><span class=line><span class=cl><span class=n>SDL_RenderPresent</span><span class=p>(</span><span class=n>renderer</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=initialize-our-game-object>Initialize our game object<a hidden class=anchor aria-hidden=true href=#initialize-our-game-object>#</a></h3><p><code>Setup()</code> is usually a function that is called once, at the beginning of your game. It can be used to initialize our game object values and properties.</p><h3 id=drawing-a-png-texture>Drawing a PNG Texture<a hidden class=anchor aria-hidden=true href=#drawing-a-png-texture>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>    <span class=n>SDL_Surface</span><span class=o>*</span> <span class=n>surface</span> <span class=o>=</span> <span class=n>IMG_Load</span><span class=p>(</span><span class=s>&#34;./assets/images/tank-tiger-right.png&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_Texture</span><span class=o>*</span> <span class=n>texture</span> <span class=o>=</span> <span class=n>SDL_CreateTextureFromSurface</span><span class=p>(</span><span class=n>renderer</span><span class=p>,</span> <span class=n>surface</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_FreeSurface</span><span class=p>(</span><span class=n>surface</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SDL_Rect</span> <span class=n>dstRect</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>SDL_RenderCopy</span><span class=p>(</span><span class=n>renderer</span><span class=p>,</span> <span class=n>texture</span><span class=p>,</span> <span class=o>&lt;</span><span class=n>srcRect</span><span class=o>&gt;</span><span class=p>,</span><span class=o>&lt;</span><span class=n>dstRect</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>SDL_DestroyTexture</span><span class=p>(</span><span class=n>texture</span><span class=p>);</span>
</span></span></code></pre></div><p>This code loads a PNG image from disk, converts it into a format that the GPU can draw, and then renders it on the screen.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_Surface</span><span class=o>*</span> <span class=n>surface</span> <span class=o>=</span> <span class=n>IMG_Load</span><span class=p>(</span><span class=s>&#34;./assets/images/tank-tiger-right.png&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>When we call <code>IMG_Load</code>, SDL loads the PNG file and places the pixel data into a <code>surface</code>. A <code>surface</code> is simply raw image data stored in normal RAM. It represents an image that the CPU can access, but it is not in a format that the GPU can draw efficiently.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_Texture</span><span class=o>*</span> <span class=n>texture</span> <span class=o>=</span> <span class=n>SDL_CreateTextureFromSurface</span><span class=p>(</span><span class=n>renderer</span><span class=p>,</span> <span class=n>surface</span><span class=p>);</span>
</span></span></code></pre></div><p>To render the image on the screen, we must convert the surface into a <code>texture</code>. A <code>texture</code> is the GPU-friendly version of the image. Textures live on the graphics card and can be drawn very efficiently by the renderer.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_FreeSurface</span><span class=p>(</span><span class=n>surface</span><span class=p>);</span>
</span></span></code></pre></div><p>After converting the image into a texture, the original surface is no longer needed, so we free it to avoid wasting memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_Rect</span> <span class=n>dstRect</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>32</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>SDL_RenderCopy</span><span class=p>(</span><span class=n>renderer</span><span class=p>,</span> <span class=n>texture</span><span class=p>,</span> <span class=o>&lt;</span><span class=n>srcRect</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=n>dstRect</span><span class=o>&gt;</span><span class=p>);</span>
</span></span></code></pre></div><p>Finally, <code>SDL_RenderCopy</code> copies the texture onto the current back buffer. The <code>srcRect</code> specifies which part of the texture to use, and the <code>dstRect</code> specifies where and how large it should appear on the screen.
In most of the case, we want to use the entire texture. So, If you want to draw the whole image, you can pass <code>NULL</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SDL_DestroyTexture</span><span class=p>(</span><span class=n>texture</span><span class=p>);</span>
</span></span></code></pre></div><p>After converting an image into a <code>texture</code> and drawing it with <code>SDL_RenderCopy</code>, we should free the memory used by the texture when we are done with it. SDL textures live on the GPU, which means they consume graphics memory. If we never destroy them, the GPU memory will eventually fill up, causing performance problems or crashes. To release the texture properly, we call <code>SDL_DestroyTexture</code>.</p><p>This tells SDL to remove the texture from the GPU and free all resources associated with it. It is the GPU equivalent of freeing a surface with <code>SDL_FreeSurface</code>. Always make sure to destroy textures once you are done drawing them, especially inside loops or when loading many images.</p><h2 id=fixing-the-game-time-step>Fixing the Game Time Step<a hidden class=anchor aria-hidden=true href=#fixing-the-game-time-step>#</a></h2><h3 id=object-movement-and-velocity-vectors>Object Movement and Velocity Vectors<a hidden class=anchor aria-hidden=true href=#object-movement-and-velocity-vectors>#</a></h3></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/blog4.1/><span class=title>Next »</span><br><span>ダミー記事：文章のみのサンプル</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on x" href="https://x.com/intent/tweet/?text=2dgameengine&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f&amp;title=2dgameengine&amp;summary=2dgameengine&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f&title=2dgameengine"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on whatsapp" href="https://api.whatsapp.com/send?text=2dgameengine%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on telegram" href="https://telegram.me/share/url?text=2dgameengine&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 2dgameengine on ycombinator" href="https://news.ycombinator.com/submitlink?t=2dgameengine&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fblog3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=http://localhost:1313/>雄一のサイト</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>